= JEP-0000: Opt-in Continuous Delivery of Jenkins Plugin Releases
:toc: preamble
:toclevels: 3
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

.Metadata
[cols="1h,1"]
|===
| JEP
| 0000

| Title
| Opt-in Continuous Delivery of Jenkins Plugin Releases from Trusted CI

| Sponsor
| link:https://github.com/daniel-beck[Daniel Beck]

// Use the script `set-jep-status <jep-number> <status>` to update the status.
| Status
| Draft :speech_balloon:

| Type
| Process :bulb:

| Created
| Date (2019-05-15) :bulb:

| BDFL-Delegate
| TBD

//
//
// Uncomment if there is an associated placeholder JIRA issue.
//| JIRA
//| :bulb: https://issues.jenkins-ci.org/browse/JENKINS-nnnnn[JENKINS-nnnnn] :bulb:
//
//
// Uncomment if discussion will occur in forum other than jenkinsci-dev@ mailing list.
//| Discussions-To
//| :bulb: Link to where discussion and final status announcement will occur :bulb:
//
//
// Uncomment if this JEP depends on one or more other JEPs.
//| Requires
//| :bulb: JEP-NUMBER, JEP-NUMBER... :bulb:
//
//
// Uncomment and fill if this JEP is rendered obsolete by a later JEP
//| Superseded-By
//| :bulb: JEP-NUMBER :bulb:
//
//
// Uncomment when this JEP status is set to Accepted, Rejected or Withdrawn.
//| Resolution
//| :bulb: Link to relevant post in the jenkinsci-dev@ mailing list archives :bulb:

|===

== Abstract

This JEP introduces a new system, which enables Jenkins plugin maintainers to add Continuous 
Delivery to their projects. It is:

* Opt-in: plugin maintainers can choose to use this
* Simple to configure: very little needs to be changed in order to enable CD
* Trusted CI/CD: deployments are produced from a single source of truth, which is managed by 
the Jenkins project

== Specification

=== Overview

We'll use a short story to illustrate what Autorelease will look like when a plugin maintainer 
decides that they want to take part.

Karl, a plugin developer who owns the fancy-branch-plugin, wants to add CD to his project. To do so, 
he will:

1. Verify support. Karl's plugin is already in the jenkinsci Organization on GitHub, and is 
using `buildPlugin` when built on ci.jenkins.io.

2. Choose a branch from which to release. Karl decides he wants to release from the `master` branch, 
as that is the simplest.

3. Settle on a version numbering scheme. Becuase it's in fairly wide use across the Jenkins 
ecosystem, Karl settles on link:https://semver.org/[semantic versioning].

4. Add a file to the top directory of his repository called `Autorelease.yaml`. 

5. A webhook is configured on Karl's repository on GitHub to point to `{the-webhook-receiver}`

Once ready to create a new release of his plugin, Karl merges some changes to the `master` branch. 
At which point, the following takes place under the covers: 

1. A webhook is sent to `{the-webhook-receiver}` by GitHub

2. The receiver forwards this hook to `${trusted-ci-server}`, which is protected by a VPN

3. `${trusted-ci-server}` uses the enhanced version of `buildPlugin` to validate the correctness of 
Karl's `Autorelease.yaml` file, and the consistency of Karl's chosen version numbering.

4. Once `Autorelease.yaml` has been validated, a plugin build is performed on `${trusted-ci-server}` 
as one would expect.

5. After the build is successful, `${trusted-ci-server}` handles deployment of the built plugin to 
Artifactory and the Jenkins Update Center.

=== Detailed Setup

==== Autorelease.yaml

A YAML markerfile, stored in the plugin's own repository. Absence of this markerfile will 
be functionally equivalent to the plugin maintainer opting out of Autorelease. 

In the following example, we'll use a fictional plugin, called `fancy-branch-source`

```
plugin: fancy-branch-source
kind: plugin
metadata:
  autoreleaseEnabled: true
  triggeringBranch: master
  versionNumberFields: 3
```

In the above example `Autorelease.yaml`, we can see the following:

`plugin: fancy-branch-source`:: 
This is the name of the plugin, and it matches the repository 
name on GitHub.
`kind`:: 
The type of project which is being set up for autorelease. In our first iteration of 
autorelease, this will only be set to `plugin`. The field is here should the Jenkins project 
want to expand the use of autorelease, such as for building core, or components
`metadata`:: 
Contains the following fields:
** `autoreleaseEnabled`: A boolean value, indicating whether or not this plugin is participating in autorelease
** `triggeringBranch`: Sets the branch which maintainers will merge to in order to trigger 
an autorelease webhook. Although this is expected to usually be set to `master`, plugin 
maintainers can choose a branch name of their preference, e.g., `autorelease`, `release`, 
etc.
** `versionNumberFields`: An integer, indicating the number of fields which `buildPlugin` should expect.
This is important, because sticking to a consistent numbering scheme makes for easier sorting by version.
For this example plugin, Karl has set the value to `3`, because he's usuing semantic versioning, e.g., 
3.1.4.

==== Maven POM file changes

Karl's plugin is already making use of Incrementals, and the relevant lines of his `pom.xml` file 
look like:

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.jenkins-ci.plugins</groupId>
        <artifactId>plugin</artifactId>
        <version>4.56</version>
        <relativePath />
    </parent>
    <artifactId>fancy-branch-source</artifactId>
    <version>${revision}${changelist}</version>
    <packaging>hpi</packaging>
    <name>Fancy Branch Source Plugin</name>
    <url>
        <!--Something like https://wiki.jenkins-ci.org/display/JENKINS/Fancy+Branch+Source+Plugin-->
    </url>
    <description>A useful description.</description>
    <licenses>
        <license>
            <name>MIT</name>
            <url>http://opensource.org/licenses/MIT</url>
        </license>
    </licenses>

    <properties>
        <revision>3.1.4</revision>
        <changelist>-SNAPSHOT</changelist>
        <java.level>8</java.level>
        <jenkins.version>2.138.4</jenkins.version>
    </properties>

```

No additional changes need to be made to `pom.xml` by Karl, he's good to go.

=== What happens when a release is created

==== Changes to `buildPlugin`

The commonly used library link:https://github.com/jenkins-infra/pipeline-library/blob/master/vars/buildPlugin.groovy[`buildPlugin`] will need to be modified to check for, and validate, the markerfile, called `Autorelease.yaml`. This 
markerfile will be the mechanism that tells `${trusted-ci-server}` that this plugin should be automatically 
released.

Validation will include:

1. The 

If validation of `Autorelease.yaml` fails for any reason, the build is not performed and nothing gets deployed.


When Karl merges a commit into the `master` branch, that merge commit has the 
SHA `1a2b3c4`. The following takes place:

* A webhook is sent to `${trusted-ci-server}`, and a build is performed there. 
* If the build passes all its tests, a release is generated. In our example, 
that release number would be `3.1.4-1a2b3c4`, because Karl has chosen to append the merge commit 
SHA to the end of his autorelease version numbers.
* The built plugin gets deployed to Nexus
* The resulting plugin appears on the Jenkins Update Center

== Motivation

At present, Jenkins plugins are, typically, not released on a continous basis. They 
are also not released from a single source of truth, such as a trusted Continuous 
Integration server like link:https://ci.jenkins.io[https://ci.jenkins.io]. 

The notion of continuous delivery of plugin releases has been discussed previously <<footnote-1,^(1)^>>.
Considering that Jenkins is a system used to facilitate Continuous Delivery for many users, it makes 
sense -- and builds credibility -- for the Jenkins developer community to adopt this same practice. 

Having a centralized release system made available to plugin maintainers also provides additional 
confidence that security best practices are being followed *need footnote without surfacing some 
awful security problem* 

Continuous celivery from trusted CI is something which plugin maintainers can opt into, but is 
not required. If a plugin maintainer chooses to continue to follow their own path for releasing 
versions of their code, they remain free to do so.

== Reasoning

=== Why a trusted CI system?
Containment of credentials. By using a single system of record for these builds, a service account, maintained by the JENKINS-CERT team, can be used to access GitHub, deploy to Nexus, and deploy to the update centers.

=== Why YAML?
YAML is becoming increasingly common in the Jenkins community, for many reasons. YAML is:

* Already in use by the Tekton project in Jenkins-X
* Human readable
* In use for things like the Kubernetes plugin
* Easily parsed by any number of publily available libraries

== Backwards Compatibility

Autorelease introduces no new risks with regard to backwards compatibility of plugins themselves. 
However, there will be a requirement for plugin maintainers to use a consistent version numbering 
scheme. Consistent version numbering will prevent problems with sorting versions 

With any plugin upgrade, there are backwards compatibility concerns, and Autorelease is no different 
in that regard. Without Autorelease, there is still nothing stopping a plugin maintainer from releasing 
a backwards-breaking change.

Plugin maintainers are also not required to use Autorelease at all. By taking no action, these 
maintainers will see no change at all to the way they do their Jenkins plugin work.

== Security

Autorelease should make things more secure, because they all come from `${trusted-ci-server}`. Rules 
can be put in place on `${trusted-ci-server}`, which can provide implicit enforcement of the 
Jenkins infrastructure team's security best practices.

== Infrastructure Requirements

We will need:

1. The webhook. Security implications of this are a bit beyond the scope of this document so far.
ALSO a receiver for the webhook. This 
2. A receiver for the aforementioned webhook, because the `${trusted-ci-server}` will be protected 
behind a VPN
3. The trusted Jenkins server doing these builds will need to be smart enough to understand the 
`Autorelease.yaml` file, and act according to its settings 
4. `buildPlugin` will need some code added to validate `Autorelease.yaml` for correctness, and 
build the plugin according to the settings described therein
5. Perhaps a mechanism by which we can verify the authenticity of incoming build requests. But this should be handled by GitHub repository permissions themselves. In other words, if Janet Plugin has merge rights to `the-janet-plugin`, she has that already today.

== Testing

Autorelease brings with it a heightened importance for quality automated tests. However, there will be 
no rules governing this. As is the case today, plugin maintainers are encouraged to release only 
well-tested code, but there is little to stop someone from releasing something which is under-tested. 
Autorelease does not change this in any way.

== Prototype Implementation

As a proof of concept, the (github-branch-source?) plugin will be the first to adopt. This provides 
the initiative with a heavily used plugin, which sees relatively frequent releases already.

A sample fork of github-branch-source could be provided as a reference implementation for 
this proposal. It is understood that this need not be completed before this JEP is 
"link:https://github.com/jenkinsci/jep/tree/master/jep/1#accepted[accepted]", but will need to 
be made available before this JEP is given 
"link:https://github.com/jenkinsci/jep/tree/master/jep/1#final[Final]" status.


== References

[[footnote-1]]1. Jenkins World 2017, link:http://bit.ly/2x1lCUZ[Contributor Summit Notes], pp. 11-12




We need to either enforce a fixed number of elements in version numbers,
OR
have it confiurable, so that:
    - More than the spec, gets rejected
    - Less than the spec, `0` gets appended

We know the problem, fixed length is one approach to fixing it.

