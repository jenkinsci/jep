= JEP-0000: Opt-in Continuous Delivery of Jenkins Plugin Releases
:toc: preamble
:toclevels: 3
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

.Metadata
[cols="1h,1"]
|===
| JEP
| 0000

| Title
| Opt-in Continuous Delivery of Jenkins Plugin Releases from Trusted CI

| Sponsor
| link:https://github.com/daniel-beck[Daniel Beck]

// Use the script `set-jep-status <jep-number> <status>` to update the status.
| Status
| Draft :speech_balloon:

| Type
| Process :bulb:

| Created
| Date (2019-05-15) :bulb:

| BDFL-Delegate
| TBD

//
//
// Uncomment if there is an associated placeholder JIRA issue.
//| JIRA
//| :bulb: https://issues.jenkins-ci.org/browse/JENKINS-nnnnn[JENKINS-nnnnn] :bulb:
//
//
// Uncomment if discussion will occur in forum other than jenkinsci-dev@ mailing list.
//| Discussions-To
//| :bulb: Link to where discussion and final status announcement will occur :bulb:
//
//
// Uncomment if this JEP depends on one or more other JEPs.
//| Requires
//| :bulb: JEP-NUMBER, JEP-NUMBER... :bulb:
//
//
// Uncomment and fill if this JEP is rendered obsolete by a later JEP
//| Superseded-By
//| :bulb: JEP-NUMBER :bulb:
//
//
// Uncomment when this JEP status is set to Accepted, Rejected or Withdrawn.
//| Resolution
//| :bulb: Link to relevant post in the jenkinsci-dev@ mailing list archives :bulb:

|===

== Abstract

This JEP introduces a new system, which enables Jenkins plugin maintainers to add Continuous 
Delivery to their projects. It is:

* Opt-in: plugin maintainers can choose to use this
* Simple to configure: very little needs to be changed in order to enable CD
* Trusted CI/CD: deployments are produced from a single source of truth, which is managed by 
the Jenkins project

== Specification

This proposal describes an approach by which plugin maintainers can have merges to a branch of their 
choice occur, an automated release process is launched. It is anticipated that the typical scenario 
will be `master`. In other words, once a commit is merged to master in the repository hosted in 
link:https://github.com/jenkinsci/[the jenkinsci organization on GitHub], a webhook will be sent to 
`super-trusted-ci.jenkins.io`. The specifics of this webhook, and the trusted CI server `super-trusted`, 
will be described on their own in an IEP document.

We suggest the use of 
link:https://semver.org/[semantic versioning], although it is not required.

=== Setup

Setup could be as simple as making two changes to the way plugins are released. 
The first of which would be changes to the 
link:https://github.com/jenkins-infra/pipeline-library/blob/master/vars/buildPlugin.groovy[`buildPlugin`] shared 
library, which is commonly used to build Jenkins plugins. 

==== Changes to `buildPlugin`

The commonly used library link:https://github.com/jenkins-infra/pipeline-library/blob/master/vars/buildPlugin.groovy[`buildPlugin`] will need to be modified to check for, and validate, a markerfile, called `Autorelease.yaml`. This 
markerfile will be the mechanism that tells `${trusted-ci-server}` that this plugin should be automatically 
released.

==== Autorelease.yaml

A YAML markerfile, stored in the plugin's own repository. Absence of this markerfile will 
be functionally equivalent to the plugin maintainer opting out of Autorelease. 

In the following example, we'll use a fictional plugin, called `fancy-branch-source`

```
plugin: fancy-branch-source
kind: plugin
metadata:
  autoreleaseEnabled: true
  triggeringBranch: master
  appendMergeSHA: true
```

In the above example `Autorelease.yaml`, we can see the following:

`plugin: fancy-branch-source`:: 
This is the name of the plugin, and it matches the repository 
name on GitHub.
`kind`:: 
The type of project which is being set up for autorelease. In our first iteration of 
autorelease, this will only be set to `plugin`. The field is here should the Jenkins project 
want to expand the use of autorelease, such as for building core, or components
`metadata`:: 
Contains the following fields:
** `autoreleaseEnabled`: A boolean value, indicating whether or not this plugin is participating in autorelease
** `triggeringBranch`: Sets the branch which maintainers will merge to in order to trigger 
an autorelease webhook. Although this is expected to usually be set to `master`, plugin 
maintainers can choose a branch name of their preference, e.g., `autorelease`, `release`, 
etc.
** `appendMergeSHA`: A boolean value, indicating whether or not the resultant release will 
be version numbered including the merge SHA, for example, `2.5.2-1a2b3c4`. This will maintain 
compatibility with the existing Incrementals versioning.

=== Adoption

To illustrate how this would be used by a plugin maintainer, we'll continue with our fictional example.
Plugin maintainer Karl has decided that he would like to automatically release fancy-branch-source 
automatically, each time he merges to a branch called `release-the-fanciness`. 

Karl's plugin is already making use of Incrementals, and the relevant lines of his `pom.xml` file 
look like:

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.jenkins-ci.plugins</groupId>
        <artifactId>plugin</artifactId>
        <version>4.56</version>
        <relativePath />
    </parent>
    <artifactId>fancy-branch-source</artifactId>
    <version>${revision}${changelist}</version>
    <packaging>hpi</packaging>
    <name>Fancy Branch Source Plugin</name>
    <url>
        <!--Something like https://wiki.jenkins-ci.org/display/JENKINS/Fancy+Branch+Source+Plugin-->
    </url>
    <description>A useful description.</description>
    <licenses>
        <license>
            <name>MIT</name>
            <url>http://opensource.org/licenses/MIT</url>
        </license>
    </licenses>

    <properties>
        <revision>3.1.4</revision>
        <changelist>-SNAPSHOT</changelist>
        <java.level>8</java.level>
        <jenkins.version>2.138.4</jenkins.version>
    </properties>

```

This is all pretty run-of-the-mill stuff for a Jenkins plugin, and is well understood already 
by Karl and the rest of the plugin maintainer community. To enable autorelease, Karl would 
create a file at the top level of his repository, called `Autorelease.yaml`:

```
plugin: fancy-branch-source
kind: plugin
metadata:
  autoreleaseEnabled: true
  triggeringBranch: release-the-fanciness
  appendMergeSHA: true
```

When Karl merges a commit into the `release-the-fanciness` branch, that merge commit has the 
SHA `1a2b3c4`. The following takes place:

* A webhook is sent to `${trusted-ci-server}`, and a build is performed there. 
* If the build passes all its tests, a release is generated. In our example, 
that release number would be `3.1.4-1a2b3c4`, because Karl has chosen to append the merge commit 
SHA to the end of his autorelease version numbers.
* The built plugin gets deployed to Nexus
* The resulting plugin appears on the Jenkins Update Center

== Motivation

At present, Jenkins plugins are, typically, not released on a continous basis. They 
are also not released from a single source of truth, such as a trusted Continuous 
Integration server like link:https://ci.jenkins.io[https://ci.jenkins.io]. 

The notion of continuous delivery of plugin releases has been discussed previously <<footnote-1,^(1)^>>.
Considering that Jenkins is a system used to facilitate Continuous Delivery for many users, it makes 
sense -- and builds credibility -- for the Jenkins developer community to adopt this same practice. 

Having a centralized release system made available to plugin maintainers also provides additional 
confidence that security best practices are being followed *need footnote without surfacing some 
awful security problem* 

Continuous celivery from trusted CI is something which plugin maintainers can opt into, but is 
not required. If a plugin maintainer chooses to continue to follow their own path for releasing 
versions of their code, they remain free to do so.

== Reasoning

=== Why a trusted CI system?
Containment of credentials. By using a single system of record for these builds, a service account, maintained by the JENKINS-CERT team, can be used to access GitHub, deploy to Nexus, and deploy to the update centers.

=== Why YAML?
YAML is becoming increasingly common in the Jenkins community, for many reasons. YAML is:

* Already in use by the Tekton project in Jenkins-X
* Human readable
* In use for things like the Kubernetes plugin
* Easily parsed by any number of publily available libraries
* 

== Backwards Compatibility

Autorelease introduces no new risks with regard to backwards compatibility or a lack thereof.

With any plugin upgrade, there are backwards compatibility concerns, and Autorelease is no different 
in that regard. Without Autorelease, there is still nothing stopping a plugin maintainer from releasing 
a backwards-breaking change.

Plugin maintainers are also not required to use Autorelease at all. By taking no action, these 
maintainers will see no change at all to the way they do their Jenkins plugin work.

== Security

Autorelease should make things more secure, because they all come from `${trusted-ci-server}`. Rules 
can be put in place on `${trusted-ci-server}` which prevent people from doing silly things.
It also eliminates the potential for MitM attacks.

== Infrastructure Requirements

We will need:

1. The webhook. Security implications of this are a bit beyond the scope of this document so far.
2. The trusted Jenkins server doing these builds will need to be smart enough to understand the 
`Autorelease.yaml` file, and act according to its settings 
3. Probably `buildPlugin` will need some code added to validate the contents of `Autorelease.yaml`. 
Otherwise there's no telling what people might put in there. This needs to be well-hardened before 
people start using it.
4. Perhaps a mechanism by which we can verify the authenticity of incoming build requests. But this should be handled by GitHub repository permissions themselves. In other words, if Janet Plugin has merge rights to `the-janet-plugin`, she has that already today.

== Testing

Autorelease brings with it a heightened importance for quality automated tests. However, there will be 
no rules governing this. As is the case today, plugin maintainers are encouraged to release only 
well-tested code, but there is little to stop someone from releasing something which is under-tested. 
Autorelease does not change this in any way.

== Prototype Implementation

As a proof of concept, the (github-branch-source?) plugin will be the first to adopt. This provides 
the initiative with a heavily used plugin, which sees relatively frequent releases already.

A sample fork of github-branch-source could be provided as a reference implementation for 
this proposal. It is understood that this need not be completed before this JEP is 
"link:https://github.com/jenkinsci/jep/tree/master/jep/1#accepted[accepted]", but will need to 
be made available before this JEP is given 
"link:https://github.com/jenkinsci/jep/tree/master/jep/1#final[Final]" status.


== References

[[footnote-1]]1. Jenkins World 2017, link:http://bit.ly/2x1lCUZ[Contributor Summit Notes], pp. 11-12



